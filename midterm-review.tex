\documentclass[draft]{article}
\usepackage{midterm-review}
\begin{document}
\include{titlepage}

\section{Introduction to Security}
\subsection{Objectives}
\begin{center}
    \begin{tabular}{lll}
                                        & \multicolumn{1}{c}{Term}  & \multicolumn{1}{c}{Definition}             \\\toprule
        \multirow{3}{*}{\acrshort{cia}} & \Glsname{confidentiality} & \glstext*{confidentiality}                 \\
                                        & \Glsname{integrity}       & \glstext*{integrity}                       \\
                                        & \Glsname{availability}    & \glstext*{availability}                    \\\midrule
                                        & \Glsname{non-repudiation} & \multirow{2}{*}{\glsdesc*{accountability}} \\
                                        & \Glsname{accountability}  &                                            \\\midrule
                                        & \Glsname{privacy}         & \glstext*{privacy}                         \\\bottomrule
    \end{tabular}
\end{center}

\subsection{Challenges}
\Gls{weakest link} -- \glsdesc*{weakest link}

Security is a process, not a product -- attackers continuously looking for new vulnerabilities, so systems must be regularly updated and continuously monitored.
\begin{multicols}{2}
    Tension between security and
    \begin{itemize}[nosep]
        \item usability
        \item functionality
        \item efficiency
        \item time-to-market
        \item development cost
    \end{itemize}

    Value of security often only perceived when there is a security failure

    Can be measured by
    \begin{itemize}[nosep]
        \item checking compliance
        \item pentesting
    \end{itemize}
\end{multicols}
\section{Introduction to Cryptography}
\subsection{Attacker Modeling Principles}
\begin{multicols}{2}
    Security is defined with respect to an \gls{attacker model} -- what the attacker
    \begin{itemize}[nosep]
        \item can do
        \item knows
        \item wants to achieve
    \end{itemize}

    Generally better to overestimate the attacker's capabilities, knowledge, and determination.

    Safe to assume attacker knows
    \begin{itemize}[nosep]
        \item algorithms
        \item system design
        \item implementation
        \item configuaration
    \end{itemize}
    but the attacker cannot know \emph{truly} random values.
\end{multicols}
\subsection{Security by Obscurity}
\Gls{security by obscurity} -- \glsdesc*{security by obscurity}

Generally rejected by security experts, researchers, standard bodies, i.e., everyone.

Obscurity can slow down, but not stop, an attack:
\begin{itemize}[nosep]
    \item if we thought of something, attacker might also
    \item attacker might try attack for many possible design/implementation choices
\end{itemize}
Can create false sense of security.
\subsection{Symmetric-Key Ciphers}
Sender and receiver share a secret key $k$
\begin{center}
    \begin{tikzpicture}[node distance=3cm]
        \node[label=below:{$p$}] (p) {plaintext};
        \node[draw,rectangle,label=below:{encryption}, right of=p] (e) {$E$};
        \node[label=below:{$c=E(k,p)$}, right of=e] (c) {ciphertext};
        \node[draw,rectangle,label=below:{decryption}, right of=c] (d) {$D$};
        \node[label=below:{$p=D(k,c)$}, right of=d] (pd) {plaintext};
        \node[label=below:{$k$}, above=1cm of c] (k) {secret key};

        \draw[gray,thick,->] (p) -- (e);
        \draw[gray,thick,->] (e) -- (c);
        \draw[gray,thick,->] (c) -- (d);
        \draw[gray,thick,->] (d) -- (pd);
        \draw[gray,thick,->] (k.west) -- (e.north);
        \draw[gray,thick,->] (k.east) -- (d.north);
    \end{tikzpicture}
\end{center}
Types of attacks:
\begin{center}
    \begin{tabular}{lll}
        \multicolumn{1}{c}{Acronym} & \multicolumn{1}{c}{Attack}              & \multicolumn{1}{c}{Description}     \\\toprule
        \acrshort*{coa}             & \glsshortname{ciphertext only attack}   & \glstext*{ciphertext only attack}   \\
        \acrshort*{kpa}             & \glsshortname{known plaintext attack}   & \glstext*{known plaintext attack}   \\
        \acrshort*{cca}             & \glsshortname{chosen ciphertext attack} & \glstext*{chosen ciphertext attack} \\
        \acrshort*{cpa}             & \glsshortname{chosen plaintext attack}  & \glstext*{chosen plaintext attack}  \\
        \acrshort*{cta}             & \glsshortname{chosen text attack}       & \glstext*{chosen text attack}       \\\midrule
                                    & \glsshortname{brute-force attack}       & \glstext*{brute-force attack}       \\
                                    & \glsshortname{cryptanalytic attack}     & \glstext*{cryptanalytic attack}     \\\bottomrule
    \end{tabular}
\end{center}

\subsection{Kerckhoffsâ€™s Principle}
\Glsname{Kerckhoffs} -- \glsdesc*{Kerckhoffs}. Rejection of \glsname{security by obscurity}
\section{Stream Ciphers}
\subsection{Perfect Security}
\begin{multicols}{2}
    \Gls{perfect security} -- \glsdesc*{perfect security}

    \Gls{one-time pad} -- \glsdesc*{one-time pad}
\end{multicols}
\subsection{Semantic Security}
\Gls{semantic security} -- \glsdesc*{semantic security}
\begin{multicols}{2}
    Many-time pad: reusing the one-time key for multiple plaintext. Attacker can recover $p_1 \xor p_2$:
    \begin{align*}c_1 \xor c_2
         & = (p_1 \xor k) \xor (p_2 \xor k) \\
         & = (p_1 \xor p_2) \xor (k \xor k) \\
         & = p_1 \xor p_2
    \end{align*}
    and if attacker knows $p_1$, can recover $p_2$:
    \begin{align*}p_1 \xor (c_1 \xor c_2)
         & = p_1 \xor (p_1 \xor p_2) \\
         & = (p_1 \xor p_1) \xor p_2 \\
         & = p_2
    \end{align*}
\end{multicols}
\subsection{General Model of Stream Ciphers}
Make one-time pad practical by securely extending the key.
\subsubsection*{Pseudorandom Number Generator}
\acrfull{prng} -- \glsdesc*{pseudorandom number generator}

Requirements:
\begin{itemize}[nosep]
    \item performance -- generates key as long as plaintext, so must be computationally efficient
    \item security -- generated sequence must be indistinguishable from true randomness
          \begin{itemize}
              \item \glsname{cryptanalytic attack}
                    \begin{itemize}[nosep]
                        \item uniform distribution -- 0s and 1s occur with approximately same frequency
                        \item independence -- no subsequence can be inferred from another, disjoint subsequence
                    \end{itemize}
              \item \glsname{brute-force attack}
                    \begin{itemize}[nosep]
                        \item $n$ bit key has $2^n$ possible values -- attacker can try all
                        \item key must be sufficiently long -- in 2014, NIST recommends 112-bits
                        \item as computers become faster, key length must be increased
                    \end{itemize}
          \end{itemize}
\end{itemize}

\subsubsection*{How Stream Cipher Works}
\glsname{stream cipher} -- \glsdesc*{stream cipher}

Use \acrshort{prng} to generate the sequence up to the length of the plaintext, then to
\begin{itemize}[nosep, align=left, leftmargin=1in]
    \item[\textbf{encrypt} ---] \textproc{xor} plaintext with key
    \item[\textbf{decrypt} ---] \textproc{xor} ciphertext with key
\end{itemize}
\subsection{Key-Reuse Problem}
If attacker learns $p_1 \xor p_2$, $p_2 \xor p_3$, $p_1 \xor p_3$, $\dots$, they can recover other plaintexts.
Solutions:
\begin{itemize}[nosep]
    \item one continuous sequence that allows seeking to any position in the key
    \item \glsname{nonce} -- \glsdesc{nonce}
          \begin{itemize}[nosep]\item xor key with \glsname{nonce} for each plaintext to produce different key\end{itemize}
\end{itemize}
\begin{multicols}{2}
    \subsection{RC4}
    Old WiFi and Web Security standard

    \glsname{rc4}
    Advantages
    \begin{itemize}[nosep]
        \item variable key length (from 8 to 2048 bits)
        \item very simple, uses byte-oriented operations:
              \begin{itemize}[nosep]\item only 8 to 16 machine operations required per output byte\end{itemize}
    \end{itemize}
    Applications
    \begin{itemize}[nosep]
        \item Wifi: WEP and WPA
              \begin{itemize}[nosep]\item broken in 2001, deprecated in 2004\end{itemize}
        \item Web Security (HTTPS): SSL and TLS
              \begin{itemize}[nosep]\item broken in 2013, deprecated in 2015\end{itemize}
    \end{itemize}
    RC4 has been retired.
    \subsection{Salsa20/ChaCha20}
    State of the Art Stream Cipher
    \glsname{salsa20} (and more secure, more efficient variant \glsname{chacha20})

    Key length is 128 or 256 bits.

    \subsubsection*{Advantages}
    \begin{itemize}[nosep]
        \item fast software implementation (simple 32-bit operations)
        \item can seek to any position in output sequence
        \item 64-bit nonce part of algorithm to prevent key-reuse
    \end{itemize}
    currently, no attacks better than \glsname{brute-force attack} known.

    \subsubsection*{Algorithm}
    \begin{itemize}[nosep]
        \item Output in blocks of $16\times32$ bits
        \item internal state: $16\times 32$ bits
              \begin{itemize}[nosep]\item initialized using key, nonce, and seek position\end{itemize}
        \item State updated with \textproc{xor}, 32-bit addition mod $2^{32}$, and rotating 32 bit values
        \item Performs 20 rounds of \textproc{xor}-add-rotate, each of which updates all values in state
        \item State added to original state to obtain output
    \end{itemize}
\end{multicols}
\section{Block Ciphers}
\begin{multicols}{2}
    Unlike \glspl{stream cipher}, \glspl{block cipher} have different encryption and decryption operations. A block cipher encrypts plaintext in fixed-length blocks
    \subsection{Design Considerations}
    \begin{itemize}[nosep]
        \item Key Size
              \begin{itemize}[nosep]
                  \item number of possible $k$-bit keys is $2^k$
                  \item $k$ must be sufficiently large to prevent \glsplural{brute-force attack}
              \end{itemize}
        \item Block Size
              \begin{itemize}
                  \item too short $\rightarrow$ does not hide patterns in plaintext
                        \begin{itemize}
                            \item e.g. $n=8$ bits is 1 character
                            \item same as \glsname{substitution cipher}
                        \end{itemize}
                  \item too long -- impractical, wasteful
              \end{itemize}
        \item encryption must be invertible
              \begin{itemize}
                  \item different input blocks must be transformed into different output blocks
                  \item can be viewed as a permutation on all $n$-bit blocks
                  \item $(2^n)!$ possible permutations
              \end{itemize}
    \end{itemize}
    \resizebox{0.45\textwidth}{!}{
        \begin{tikzpicture}[node distance=2.25cm, every node/.style={rectangle, draw, minimum width=2cm}]
            \node[label=above:{key}] (k) {$k$};
            \node[above right = 0.25cm and 0.5cm of k] (p1) {$p_1$};
            \node[right of=p1, label=above:{plaintext}] (p2) {$p_2$};
            \node[right of=p2] (p3) {$p_3$};

            \node[below of=p1] (e1) {$E(k, p_1)$};
            \node[below of=p2] (e2) {$E(k, p_2)$};
            \node[below of=p3] (e3) {$E(k, p_3)$};

            \node[below of=e1] (c1) {$c_1$};
            \node[below of=e2, label=below:{ciphertext}] (c2) {$c_2$};
            \node[below of=e3] (c3) {$c_3$};

            \draw[->] (p1) -- (e1);
            \draw[->] (e1) -- (c1);

            \draw[->] (p2) -- (e2);
            \draw[->] (e2) -- (c2);

            \draw[->] (p3) -- (e3);
            \draw[->] (e3) -- (c3);

            \draw[->] (k) -| ([xshift=0.5cm]e1.north west);
            \draw[->] (k) -| ([xshift=0.5cm]e2.north west);
            \draw[->] (k) -| ([xshift=0.5cm]e3.north west);
        \end{tikzpicture}}
\end{multicols}
\subsection{Secure Block Cipher}
An $n$-bit \glsname{block cipher} is secure (for a computationally bounded attacker) if it is indistinguishable from a random permutation of $n$-bit blocks.

\glsname{diffusion} -- \glsdesc{diffusion}
\hrule
\begin{center}
    \begin{tikzpicture}[every node/.style={draw, rectangle}, minimum size=0.5cm, node distance=0.05cm]
        \node[label=left:{plaintext block}] (b1) {1};
        \node[right=of b1] (b2) {0};
        \node[right=of b2] (b3) {0};
        \node[right=of b3] (b4) {0};
        \node[right=of b4,draw=red!32!black,fill=yellow,thick] (b5) {1};
        \node[right=of b5] (b6) {0};
        \node[right=of b6] (b7) {0};
        \node[right=of b7] (b8) {1};
        \node[right=of b8] (b9) {1};
        \node[right=of b9] (b10) {1};
        \node[right=of b10] (b11) {0};
        \node[right=of b11] (b12) {1};

        \node[right=1cm of b12] (k1) {1};
        \node[right=of k1] (k2) {1};
        \node[right=of k2] (k3) {0};
        \node[right=of k3] (k4) {0};
        \node[right=of k4] (k5) {0};
        \node[right=of k5,label=right:{key}] (k6) {0};


        \node[below=2cm of b1, label=left:{ciphertext block}] (c1) {0};
        \node[below=2cm of b2,draw=red!32!black,fill=yellow,thick] (c2) {1};
        \node[below=2cm of b3,draw=red!32!black,fill=yellow,thick] (c3) {0};
        \node[below=2cm of b4] (c4) {1};
        \node[below=2cm of b5,draw=red!32!black,fill=yellow,thick] (c5) {0};
        \node[below=2cm of b6] (c6) {0};
        \node[below=2cm of b7] (c7) {1};
        \node[below=2cm of b8,draw=red!32!black,fill=yellow,thick] (c8) {1};
        \node[below=2cm of b9,draw=red!32!black,fill=yellow,thick] (c9) {0};
        \node[below=2cm of b10] (c10) {0};
        \node[below=2cm of b11] (c11) {1};
        \node[below=2cm of b12,draw=red!32!black,fill=yellow,thick] (c12) {0};

        \fill[gray!40] ([yshift=-0.25cm]b1.south west) rectangle ([yshift=0.25cm]c12.north east);
        \node[below=0.75cm of b1,draw=none,label=left:{encryption}] {};

        \draw[draw=none] (b5.south) -- ([yshift=-1.5cm]b5.south) node[draw=none, pos=0.5] (center) {};
        \path[draw,thick,red!32!black] (b5.south) -- (center.center);
        \path[draw,->,thick,red!32!black] (center.center) -| (c2);
        \path[draw,->,thick,red!32!black] (center.center) -| (c3);
        \path[draw,->,thick,red!32!black] (center.center) -| (c5);
        \path[draw,->,thick,red!32!black] (center.center) -| (c8);
        \path[draw,->,thick,red!32!black] (center.center) -| (c9);
        \path[draw,->,thick,red!32!black] (center.center) -| (c12);
    \end{tikzpicture}
\end{center}
\glsname{confusion} -- \glsdesc{confusion}
\hrule
\begin{center}
    \begin{tikzpicture}[every node/.style={draw, rectangle}, minimum size=0.5cm, node distance=0.05cm]
        \node[label=left:{plaintext block}] (b1) {1};
        \node[right=of b1] (b2) {0};
        \node[right=of b2] (b3) {0};
        \node[right=of b3] (b4) {0};
        \node[right=of b4] (b5) {1};
        \node[right=of b5] (b6) {0};
        \node[right=of b6] (b7) {0};
        \node[right=of b7] (b8) {1};
        \node[right=of b8] (b9) {1};
        \node[right=of b9] (b10) {1};
        \node[right=of b10] (b11) {0};
        \node[right=of b11] (b12) {1};

        \node[right=1cm of b12] (k1) {1};
        \node[right=of k1,draw=red!32!black,fill=yellow,thick] (k2) {1};
        \node[right=of k2] (k3) {0};
        \node[right=of k3] (k4) {0};
        \node[right=of k4] (k5) {0};
        \node[right=of k5,label=right:{key}] (k6) {0};

        \node[below=2cm of b1, label=left:{ciphertext block}] (c1) {0};
        \node[below=2cm of b2,draw=red!32!black,fill=yellow,thick] (c2) {1};
        \node[below=2cm of b3,draw=red!32!black,fill=yellow,thick] (c3) {0};
        \node[below=2cm of b4] (c4) {1};
        \node[below=2cm of b5,draw=red!32!black,fill=yellow,thick] (c5) {0};
        \node[below=2cm of b6] (c6) {0};
        \node[below=2cm of b7] (c7) {1};
        \node[below=2cm of b8,draw=red!32!black,fill=yellow,thick] (c8) {1};
        \node[below=2cm of b9,draw=red!32!black,fill=yellow,thick] (c9) {0};
        \node[below=2cm of b10] (c10) {0};
        \node[below=2cm of b11] (c11) {1};
        \node[below=2cm of b12,draw=red!32!black,fill=yellow,thick] (c12) {0};

        \fill[gray!40] ([yshift=-0.25cm]b1.south west) rectangle ([yshift=0.25cm]c12.north east);
        \node[below=0.75cm of b1,draw=none,label=left:{encryption}] {};

        \draw[draw=none] (k2.south) -- ([yshift=-1.5cm]k2.south) node[draw=none, pos=0.5] (center) {};
        \path[draw,thick,red!32!black] (k2.south) -- (center.center);
        \path[draw,->,thick,red!32!black] (center.center) -| (c2);
        \path[draw,->,thick,red!32!black] (center.center) -| (c3);
        \path[draw,->,thick,red!32!black] (center.center) -| (c5);
        \path[draw,->,thick,red!32!black] (center.center) -| (c8);
        \path[draw,->,thick,red!32!black] (center.center) -| (c9);
        \path[draw,->,thick,red!32!black] (center.center) -| (c12);
    \end{tikzpicture}
\end{center}

\subsection{Iterated Block Ciphers}
Hard to design a single invertible function that satisfies \glsname{diffusion} and \glsname{confusion}. Use a round function
\begin{itemize}[nosep]
    \item $R$ -- round function
          \begin{itemize}[nosep]
              \item relatively weak transformation that introduces \glsname{diffusion} and \glsname{confusion}
              \item by iterating, builds strong block cipher
          \end{itemize}
\end{itemize}
\begin{center}
    \begin{tikzpicture}[node distance=1cm]
        \node (k) {key $k$};
        \node[below left=2cm and 2.5cm of k] (k1) {$k_1$};
        \node[right= of k1] (k2) {$k_2$};
        \node[right= of k2] (k3) {$k_3$};
        \node[below right=2cm and 2.5cm of k] (km) {$k_m$};
        \draw[draw=none] (k3) -- (km) node[pos=0.5] (emptydots) {};


        \node[minimum size=1cm,draw,rectangle,below= of k1] (r1) {$R$};
        \node[minimum size=1cm,draw,rectangle,below= of k2] (r2) {$R$};
        \node[minimum size=1cm,draw,rectangle,below= of k3] (r3) {$R$};
        \node[below= 1.5cm of emptydots] (dots) {$\dots$};
        \node[minimum size=1cm,draw,rectangle,below= of km] (rm) {$R$};
        \node[left= of r1, align=center] (plaintext) {plaintext\\block};
        \node[right= of rm, align=center] (ciphertext) {ciphertext\\block};
        \node[left=of k1] {round keys};

        \fill[gray!40] (k1.north) -- ([yshift=-0.5cm]k.south west) -- ([yshift=-0.5cm]k.south east) -- (km.north);
        \node[below =0.75cm of k,align=center] {key\\expansion};

        \draw[->] (k) -- ([yshift=-0.5cm]k.south);

        \draw[->] (k1) -- (r1.north);
        \draw[->] (k2) -- (r2.north);
        \draw[->] (k3) -- (r3.north);
        \draw[->] (km) -- (rm.north);

        \draw[->] (plaintext) -- (r1);
        \draw[->] (r1) -- (r2);
        \draw[->] (r2) -- (r3);
        \draw[->] (r3) -- (dots);
        \draw[->] (dots) -- (rm);
        \draw[->] (rm) -- (ciphertext);
    \end{tikzpicture}
\end{center}

\subsection{Substitution-Permutation Ciphers}
\begin{multicols}{2}
    Common subtype of iterated block cipher, each round $R$ consists of
    \begin{itemize}[nosep]
        \item Substitution $S$
              \begin{itemize}[nosep]
                  \item substitutes small block with another small block
                  \item ideally, changing one input bit changes half of output bits
              \end{itemize}
        \item Permutation $P$
              \begin{itemize}[nosep]
                  \item permutation of all bits
              \end{itemize}
    \end{itemize}
    \resizebox{0.4\textwidth}{!}{
        \begin{tikzpicture}[every node/.style={rectangle, draw, minimum width=1.25cm}, node distance=0.25cm]
            \node[draw=none] (p) {plaintext block};
            \node[below left=0.5cm and 0.5cm of p] (firsts1) {$S_1$};
            \node[right=of firsts1] (firsts2) {$S_2$};
            \node[right=of firsts2] (firsts3) {$S_3$};
            \node[right=of firsts3] (firsts4) {$S_4$};
            \draw[draw=none] ([yshift=-1.5cm]firsts1.south west) rectangle ([yshift=-2cm]firsts4.south east) node[pos=0.5, minimum width=5.75cm] (mix1) {mix with key};
            \node[draw=none,right=of mix1] (k1) {$k_1$};
            \node[draw=none,below left=of firsts1] {$P$};
            \draw[->] ([xshift=0.25cm]k1.west) -- (mix1);

            \draw[draw=none] (mix1.north west) -- (mix1.north east)
            node[draw=none,pos=0.043] (firstmix1) {}
            node[draw=none,pos=0.087] (firstmix2) {}
            node[draw=none,pos=0.130] (firstmix3) {}
            node[draw=none,pos=0.174] (firstmix4) {}
            node[draw=none,pos=0.304] (firstmix5) {}
            node[draw=none,pos=0.348] (firstmix6) {}
            node[draw=none,pos=0.391] (firstmix7) {}
            node[draw=none,pos=0.435] (firstmix8) {}
            node[draw=none,pos=0.565] (firstmix9) {}
            node[draw=none,pos=0.609] (firstmix10) {}
            node[draw=none,pos=0.652] (firstmix11) {}
            node[draw=none,pos=0.696] (firstmix12) {}
            node[draw=none,pos=0.826] (firstmix13) {}
            node[draw=none,pos=0.870] (firstmix14) {}
            node[draw=none,pos=0.913] (firstmix15) {}
            node[draw=none,pos=0.957] (firstmix16) {};

            \draw[draw=none] (firsts1.south west) -- (firsts1.south east)
            node[draw=none, pos=0.2] (firsts11) {}
            node[draw=none, pos=0.4] (firsts12) {}
            node[draw=none, pos=0.6] (firsts13) {}
            node[draw=none, pos=0.8] (firsts14) {};
            \path[draw,->] (firsts11.center) -- ([yshift=-0.3cm]firsts11.south) -- ([yshift=0.3cm]firstmix6.north) -- (firstmix6.center);
            \path[draw,->] (firsts12.center) -- ([yshift=-0.3cm]firsts12.south) -- ([yshift=0.3cm]firstmix4.north) -- (firstmix4.center);
            \path[draw,->] (firsts13.center) -- ([yshift=-0.3cm]firsts13.south) -- ([yshift=0.3cm]firstmix9.north) -- (firstmix9.center);
            \path[draw,->] (firsts14.center) -- ([yshift=-0.3cm]firsts14.south) -- ([yshift=0.3cm]firstmix1.north) -- (firstmix1.center);

            \draw[draw=none] (firsts2.south west) -- (firsts2.south east)
            node[draw=none, pos=0.2] (firsts21) {}
            node[draw=none, pos=0.4] (firsts22) {}
            node[draw=none, pos=0.6] (firsts23) {}
            node[draw=none, pos=0.8] (firsts24) {};
            \path[draw,->] (firsts21.center) -- ([yshift=-0.3cm]firsts21.south) -- ([yshift=0.3cm]firstmix2.north) -- (firstmix2.center);
            \path[draw,->] (firsts22.center) -- ([yshift=-0.3cm]firsts22.south) -- ([yshift=0.3cm]firstmix7.north) -- (firstmix7.center);
            \path[draw,->] (firsts23.center) -- ([yshift=-0.3cm]firsts23.south) -- ([yshift=0.3cm]firstmix5.north) -- (firstmix5.center);
            \path[draw,->] (firsts24.center) -- ([yshift=-0.3cm]firsts24.south) -- ([yshift=0.3cm]firstmix14.north) -- (firstmix14.center);

            \draw[draw=none] (firsts3.south west) -- (firsts3.south east)
            node[draw=none, pos=0.2] (firsts31) {}
            node[draw=none, pos=0.4] (firsts32) {}
            node[draw=none, pos=0.6] (firsts33) {}
            node[draw=none, pos=0.8] (firsts34) {};
            \path[draw,->] (firsts31.center) -- ([yshift=-0.3cm]firsts31.south) -- ([yshift=0.3cm]firstmix11.north) -- (firstmix11.center);
            \path[draw,->] (firsts32.center) -- ([yshift=-0.3cm]firsts32.south) -- ([yshift=0.3cm]firstmix10.north) -- (firstmix10.center);
            \path[draw,->] (firsts33.center) -- ([yshift=-0.3cm]firsts33.south) -- ([yshift=0.3cm]firstmix16.north) -- (firstmix16.center);
            \path[draw,->] (firsts34.center) -- ([yshift=-0.3cm]firsts34.south) -- ([yshift=0.3cm]firstmix3.north) -- (firstmix3.center);

            \draw[draw=none] (firsts4.south west) -- (firsts4.south east)
            node[draw=none, pos=0.2] (firsts41) {}
            node[draw=none, pos=0.4] (firsts42) {}
            node[draw=none, pos=0.6] (firsts43) {}
            node[draw=none, pos=0.8] (firsts44) {};
            \path[draw,->] (firsts41.center) -- ([yshift=-0.3cm]firsts41.south) -- ([yshift=0.3cm]firstmix12.north) -- (firstmix12.center);
            \path[draw,->] (firsts42.center) -- ([yshift=-0.3cm]firsts42.south) -- ([yshift=0.3cm]firstmix8.north) -- (firstmix8.center);
            \path[draw,->] (firsts43.center) -- ([yshift=-0.3cm]firsts43.south) -- ([yshift=0.3cm]firstmix13.north) -- (firstmix13.center);
            \path[draw,->] (firsts44.center) -- ([yshift=-0.3cm]firsts44.south) -- ([yshift=0.3cm]firstmix15.north) -- (firstmix15.center);

            \node[below=2.5cm of firsts1] (seconds1) {$S_1$};
            \draw[draw=none] (seconds1.north west) -- (seconds1.north east)
            node[draw=none, pos=0.2] (top11) {}
            node[draw=none, pos=0.4] (top12) {}
            node[draw=none, pos=0.6] (top13) {}
            node[draw=none, pos=0.8] (top14) {};
            \node[right=of seconds1] (seconds2) {$S_2$};
            \draw[draw=none] (seconds2.north west) -- (seconds2.north east)
            node[draw=none, pos=0.2] (top21) {}
            node[draw=none, pos=0.4] (top22) {}
            node[draw=none, pos=0.6] (top23) {}
            node[draw=none, pos=0.8] (top24) {};
            \node[right=of seconds2] (seconds3) {$S_3$};
            \draw[draw=none] (seconds3.north west) -- (seconds3.north east)
            node[draw=none, pos=0.2] (top31) {}
            node[draw=none, pos=0.4] (top32) {}
            node[draw=none, pos=0.6] (top33) {}
            node[draw=none, pos=0.8] (top34) {};
            \node[right=of seconds3] (seconds4) {$S_4$};
            \draw[draw=none] (seconds4.north west) -- (seconds4.north east)
            node[draw=none, pos=0.2] (top41) {}
            node[draw=none, pos=0.4] (top42) {}
            node[draw=none, pos=0.6] (top43) {}
            node[draw=none, pos=0.8] (top44) {};
            \draw[->] ([yshift=0.35cm]top11.north) -- (top11.center);
            \draw[->] ([yshift=0.35cm]top12.north) -- (top12.center);
            \draw[->] ([yshift=0.35cm]top13.north) -- (top13.center);
            \draw[->] ([yshift=0.35cm]top14.north) -- (top14.center);
            \draw[->] ([yshift=0.35cm]top21.north) -- (top21.center);
            \draw[->] ([yshift=0.35cm]top22.north) -- (top22.center);
            \draw[->] ([yshift=0.35cm]top23.north) -- (top23.center);
            \draw[->] ([yshift=0.35cm]top24.north) -- (top24.center);
            \draw[->] ([yshift=0.35cm]top31.north) -- (top31.center);
            \draw[->] ([yshift=0.35cm]top32.north) -- (top32.center);
            \draw[->] ([yshift=0.35cm]top33.north) -- (top33.center);
            \draw[->] ([yshift=0.35cm]top34.north) -- (top34.center);
            \draw[->] ([yshift=0.35cm]top41.north) -- (top41.center);
            \draw[->] ([yshift=0.35cm]top42.north) -- (top42.center);
            \draw[->] ([yshift=0.35cm]top43.north) -- (top43.center);
            \draw[->] ([yshift=0.35cm]top44.north) -- (top44.center);

            \draw[draw=none] ([yshift=-1.5cm]seconds1.south west) rectangle ([yshift=-2cm]seconds4.south east) node[pos=0.5, minimum width=5.75cm] (mix2) {mix with key};
            \node[draw=none,right=of mix2] (k2) {$k_2$};
            \node[draw=none,below left=of seconds1] {$P$};
            \draw[->] ([xshift=0.25cm]k2.west) -- (mix2);

            \draw[draw=none] (mix2.north west) -- (mix2.north east)
            node[draw=none,pos=0.043] (secondmix1) {}
            node[draw=none,pos=0.087] (secondmix2) {}
            node[draw=none,pos=0.130] (secondmix3) {}
            node[draw=none,pos=0.174] (secondmix4) {}
            node[draw=none,pos=0.304] (secondmix5) {}
            node[draw=none,pos=0.348] (secondmix6) {}
            node[draw=none,pos=0.391] (secondmix7) {}
            node[draw=none,pos=0.435] (secondmix8) {}
            node[draw=none,pos=0.565] (secondmix9) {}
            node[draw=none,pos=0.609] (secondmix10) {}
            node[draw=none,pos=0.652] (secondmix11) {}
            node[draw=none,pos=0.696] (secondmix12) {}
            node[draw=none,pos=0.826] (secondmix13) {}
            node[draw=none,pos=0.870] (secondmix14) {}
            node[draw=none,pos=0.913] (secondmix15) {}
            node[draw=none,pos=0.957] (secondmix16) {};

            \draw[draw=none] (seconds1.south west) -- (seconds1.south east)
            node[draw=none, pos=0.2] (seconds11) {}
            node[draw=none, pos=0.4] (seconds12) {}
            node[draw=none, pos=0.6] (seconds13) {}
            node[draw=none, pos=0.8] (seconds14) {};
            \path[draw,->] (seconds11.center) -- ([yshift=-0.3cm]seconds11.south) -- ([yshift=0.3cm]secondmix6.north) -- (secondmix6.center);
            \path[draw,->] (seconds12.center) -- ([yshift=-0.3cm]seconds12.south) -- ([yshift=0.3cm]secondmix4.north) -- (secondmix4.center);
            \path[draw,->] (seconds13.center) -- ([yshift=-0.3cm]seconds13.south) -- ([yshift=0.3cm]secondmix9.north) -- (secondmix9.center);
            \path[draw,->] (seconds14.center) -- ([yshift=-0.3cm]seconds14.south) -- ([yshift=0.3cm]secondmix1.north) -- (secondmix1.center);

            \draw[draw=none] (seconds2.south west) -- (seconds2.south east)
            node[draw=none, pos=0.2] (seconds21) {}
            node[draw=none, pos=0.4] (seconds22) {}
            node[draw=none, pos=0.6] (seconds23) {}
            node[draw=none, pos=0.8] (seconds24) {};
            \path[draw,->] (seconds21.center) -- ([yshift=-0.3cm]seconds21.south) -- ([yshift=0.3cm]secondmix2.north) -- (secondmix2.center);
            \path[draw,->] (seconds22.center) -- ([yshift=-0.3cm]seconds22.south) -- ([yshift=0.3cm]secondmix7.north) -- (secondmix7.center);
            \path[draw,->] (seconds23.center) -- ([yshift=-0.3cm]seconds23.south) -- ([yshift=0.3cm]secondmix5.north) -- (secondmix5.center);
            \path[draw,->] (seconds24.center) -- ([yshift=-0.3cm]seconds24.south) -- ([yshift=0.3cm]secondmix14.north) -- (secondmix14.center);

            \draw[draw=none] (seconds3.south west) -- (seconds3.south east)
            node[draw=none, pos=0.2] (seconds31) {}
            node[draw=none, pos=0.4] (seconds32) {}
            node[draw=none, pos=0.6] (seconds33) {}
            node[draw=none, pos=0.8] (seconds34) {};
            \path[draw,->] (seconds31.center) -- ([yshift=-0.3cm]seconds31.south) -- ([yshift=0.3cm]secondmix11.north) -- (secondmix11.center);
            \path[draw,->] (seconds32.center) -- ([yshift=-0.3cm]seconds32.south) -- ([yshift=0.3cm]secondmix10.north) -- (secondmix10.center);
            \path[draw,->] (seconds33.center) -- ([yshift=-0.3cm]seconds33.south) -- ([yshift=0.3cm]secondmix16.north) -- (secondmix16.center);
            \path[draw,->] (seconds34.center) -- ([yshift=-0.3cm]seconds34.south) -- ([yshift=0.3cm]secondmix3.north) -- (secondmix3.center);

            \draw[draw=none] (seconds4.south west) -- (seconds4.south east)
            node[draw=none, pos=0.2] (seconds41) {}
            node[draw=none, pos=0.4] (seconds42) {}
            node[draw=none, pos=0.6] (seconds43) {}
            node[draw=none, pos=0.8] (seconds44) {};
            \path[draw,->] (seconds41.center) -- ([yshift=-0.3cm]seconds41.south) -- ([yshift=0.3cm]secondmix12.north) -- (secondmix12.center);
            \path[draw,->] (seconds42.center) -- ([yshift=-0.3cm]seconds42.south) -- ([yshift=0.3cm]secondmix8.north) -- (secondmix8.center);
            \path[draw,->] (seconds43.center) -- ([yshift=-0.3cm]seconds43.south) -- ([yshift=0.3cm]secondmix13.north) -- (secondmix13.center);
            \path[draw,->] (seconds44.center) -- ([yshift=-0.3cm]seconds44.south) -- ([yshift=0.3cm]secondmix15.north) -- (secondmix15.center);

            \node[draw=none,below=of mix2] {$\vdots$};
        \end{tikzpicture}}
\end{multicols}
\subsection{DES}
\acrfull{des}
\begin{multicols}{2}
    \begin{itemize}[nosep]
        \item block size -- 64 bits
        \item key size -- 56 bits
              \begin{itemize}[nosep]
                  \item 56 bit random
                  \item 8 bit parity check
              \end{itemize}
        \item iterated substitution cipher of 16 rounds
        \item initial permutation
              \begin{itemize}[nosep]
                  \item no cryptographic significance
                  \item facilities loading blocks in and out of 8-bit hardware
              \end{itemize}
        \item key permutation
              \begin{itemize}[nosep]
                  \item discards parity bits
                  \item no cryptographic significance
              \end{itemize}
    \end{itemize}
    \subsubsection*{Advantages}
    \begin{itemize}[nosep]
        \item relatively secure against cryptanalytic attacks -- best attack in $2^{43}$ steps
        \item thoroughly studied and widely supported
    \end{itemize}
    \subsubsection*{Disadvantages}
    Vulnerable to \glspl{brute-force attack} -- $56$-bit key $\rightarrow$ $2^{56}$ possible keys.

    \resizebox{0.45\textwidth}{!}{
        \begin{tikzpicture}[every node/.style={rectangle, draw, fill=gray!40, minimum width=3.5cm, minimum height=1cm, drop shadow={top color=black, bottom color=white, shadow xshift=0.25em, shadow yshift=-0.25em}, rounded corners}, node distance=1cm]
            \node (initial) {Initial Permutation};
            \node[right=5.5cm of initial] (permuted) {Permuted Choice 1};
            \draw[decoration={brace,raise=0.5cm,amplitude=5mm},decorate] (initial.north west) -- (initial.north east) node[draw=none,fill=none,style=reset preactions,pos=0.5,above=1cm] {64-bit plaintext};
            \draw[decoration={brace,raise=0.5cm,amplitude=5mm},decorate] (permuted.north west) -- (permuted.north east) node[draw=none,fill=none,style=reset preactions,pos=0.5,above=1cm] {64-bit key};
            \foreach \i in {0.2,0.6,...,3.5}
            \draw[->] ([xshift=\i cm,yshift=0.5cm]initial.north west) -- ([xshift=\i cm]initial.north west);
            \foreach \i in {0.2,0.6,...,3.5}
            \draw[->] ([xshift=\i cm,yshift=0.5cm]permuted.north west) -- ([xshift=\i cm]permuted.north west);

            \node[below=of initial] (round 1) {Round 1};
            \node[right=of round 1] (pc1) {Permuted Choice 2};
            \node[right=of pc1] (l1) {Left Circular Shift};

            \node[below=of round 1] (round 2) {Round 2};
            \node[right=of round 2] (pc2) {Permuted Choice 2};
            \node[right=of pc2] (l2) {Left Circular Shift};

            \node[below=3cm of round 2] (round 16) {Round 16};
            \node[right=of round 16] (pc16) {Permuted Choice 2};
            \node[right=of pc16] (l16) {Left Circular Shift};

            \node[below=of round 16] (32 bit swap) {32-bit Swap};
            \node[below=of 32 bit swap,align=center] (inverse) {Inverse Initial\\Permutation};
            \draw[decoration={brace,mirror,raise=0.5cm,amplitude=5mm},decorate] (inverse.south west) -- (inverse.south east) node[draw=none,fill=none,style=reset preactions,pos=0.5,below=1cm] {64-bit ciphertext};
            \foreach \i in {0.2,0.6,...,3.5}
            \draw[->] ([xshift=\i cm]inverse.south west) -- ([xshift=\i cm,yshift=-0.5cm]inverse.south west);

            \draw[->] (initial) -- (round 1);
            \draw[->] (round 1) -- (round 2);
            \draw[->, dashed] (round 2) -- (round 16);
            \draw[->] (round 16) -- (32 bit swap);
            \draw[->] (32 bit swap) -- (inverse);

            \draw[->] (permuted) -- (l1);
            \draw[->] (l1) -- (l2);
            \draw[->, dashed] (l2) -- (l16);
            \draw[->] (l1) -- (pc1);
            \draw[->] (l2) -- (pc2);
            \draw[->] (l16) -- (pc16);
            \draw[->] (32 bit swap) -- (inverse);

            \draw[->] (pc1) -- (round 1) node[draw=none,fill=none,style=reset preactions,pos=0.5,above] {$k_1$};
            \draw[->] (pc2) -- (round 2) node[draw=none,fill=none,style=reset preactions,pos=0.5,above] {$k_2$};
            \draw[->] (pc16) -- (round 16) node[draw=none,fill=none,style=reset preactions,pos=0.5,above] {$k_{16}$};
        \end{tikzpicture}}
\end{multicols}
\subsection{Feistel Network}
Consists of encryption and decrpytion round
\begin{multicols}{2}
    \begin{itemize}[nosep]
        \item Encryption round
              \begin{itemize}[nosep]
                  \item input -- block from previous round (or plaintext)
                  \item divide input in half -- $L_i$ and $R_i$
                  \item derive round key $k_i$ from secret key (different each round)
                  \item output
                        \begin{align*}
                            L_{i+1} & = R_i                  \\
                            R_{i+1} & = L_i \xor F(k_i, R_i)
                        \end{align*}
              \end{itemize}
        \item Decryption round
              \begin{itemize}[nosep]
                  \item we can invert encryption without inverting $F$
                        \begin{align*}
                            R_i & = L_{i + 1}                        \\
                            L_i & = R_{i + 1} \xor F(k_i, L_{i + 1}) \\
                                & = R_{i + 1} \xor F(k_i, R_i)
                        \end{align*}
              \end{itemize}
    \end{itemize}
\end{multicols}
\begin{multicols}{2}
    \subsection{AES}
    \acrfull{aes}
    \begin{itemize}[nosep]
        \item Substitution-permutation
              \begin{itemize}[nosep]\item but \textbf{not} a Feistel network\end{itemize}
        \item each round must be invertible for decrpytion
        \item key expansion and schedule -- generates different round key each round
        \item number of rounds $n$ depends on key size $k$

              \begin{tabular}{cc}
                  $k$ & $n$ \\\toprule
                  128 & 10  \\
                  192 & 12  \\
                  256 & 14  \\\bottomrule
              \end{tabular}
    \end{itemize}
    \subsection{AES Round}
    \begin{itemize}[nosep]
        \item input
              \begin{itemize}[nosep]
                  \item 128-bit state from previous round (or plaintext) as $4\times4$ byte matrix
                  \item 128-but round key from key schedule
              \end{itemize}
        \item output -- 128-bit state
        \item each round consists of multiple steps
              \begin{itemize}[nosep]
                  \item \textproc{AddRoundKey} -- \textproc{xor} round key to state
                  \item 128-but round key from key schedule
                  \item substitution and permutation
                        \begin{itemize}[nosep]
                            \item \textproc{SubBytes}
                            \item \textproc{ShiftRows}
                            \item \textproc{MixColumns}
                        \end{itemize}
              \end{itemize}
    \end{itemize}
\end{multicols}
\begin{multicols}{3}
    \subsubsection*{\textproc{SubBytes}}
    \begin{itemize}[nosep]
        \item Each byte is replaced using an 8-bit substitution box (S-box)
              \begin{itemize}[nosep]
                  \item defined using mathematical operations: multiplicative inverse over a finite field + affine transformation
              \end{itemize}
        \item designed to resist cryptanalysis
              \begin{itemize}[nosep]
                  \item minimize correlation to linear functions
                  \item minimize difference propagation
              \end{itemize}
    \end{itemize}
    \subsubsection*{\textproc{ShiftRows}}
    \begin{itemize}[nosep]
        \item Cyclically shifts 2nd, 3rd, and 4th rows left

              \begin{tabular}{ll}
                  row & shift \\\toprule
                  2nd & 1     \\
                  3rd & 2     \\
                  4th & 3     \\\bottomrule
              \end{tabular}
        \item ensures the 4 bytes of each column are spread to 4 different columns $\rightarrow$ provides \glsname{diffusion}
              \begin{itemize}[nosep]
                  \item without this step each input byte would only affect a single column
              \end{itemize}
    \end{itemize}
    \subsubsection*{\textproc{MixColumns}}
    \begin{itemize}[nosep]
        \item Each column is multiplied by a fixed matrix
              \begin{itemize}[nosep]
                  \item invertible linear transformation
              \end{itemize}
        \item good mixing among bytes of each column $\rightarrow$ provides \glsname{diffusion}
              \begin{itemize}[nosep]
                  \item in conjunction with \textproc{ShiftRows}, ensures each output bit depends on every input bit after a few rounds
              \end{itemize}
    \end{itemize}
\end{multicols}
\subsection{AES Decryption}
\begin{itemize}[nosep]
    \item each step is invertible
          \begin{itemize}[nosep]
              \item \textproc{InvertMatrixColumns} -- multiply by matrix inverse
              \item \textproc{InvertShiftRows} -- shift rows cyclically to right
              \item \textproc{InvertSubBytes} -- invert affine transformation and multiplicative inverse
              \item \textproc{InvertAddRoundKey} -- \textproc{xor} round key to state
          \end{itemize}
    \item Round keys are used in reverse order
\end{itemize}
\subsection{AES Performance and Security}
\begin{itemize}[nosep]
    \item Operations on bytes and 32-bit words
          \begin{itemize}[nosep]\item most operations can be precomputed\end{itemize}
    \item Supported by hardware -- AES instruction set for CPUs
    \item very secure -- best known attack takes $2^{126}$ steps, only 4x faster than \glsname{brute-force attack}
\end{itemize}
\subsection{Multiple Encryption}
Use same encryption algorithm multiple times, each time with a different key

\glsname{2des}

\begin{tikzpicture}[every node/.style={minimum width=1.5cm,minimum height=0.75cm,draw,fill=gray!40,drop shadow={top color=black, bottom color=white, shadow xshift=0.25em, shadow yshift=-0.25em}, rounded corners}]
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none] (p) {$P$};
    \node[right=of p] (e1) {$E$};
    \node[right=of e1] (e2) {$E$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,right=of e2] (c) {$C=E(k_2, E(k_1, P))$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of e1] (k1) {$k_1$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of e2] (k2) {$k_2$};
    \draw[->] (p) -- (e1);
    \draw[->] (e1) -- (e2);
    \draw[->] (e2) -- (c);
    \draw[->] (k1) -- (e1);
    \draw[->] (k2) -- (e2);
\end{tikzpicture}
\subsubsection{Meet in the Middle}
\glsname{meet in the middle attack} -- trade time for storage
\begin{itemize}[nosep]
    \item \glsname{brute-force attack} requires $2^{112}$ steps
    \item store $\sqrt{2^{112}} = 2^{56}$ values, $\approx 2^{56}$ steps
    \item generally, storing $2^{56 - m} \rightarrow \approx 2^{56+m}$ steps
\end{itemize}

\glsname{3des}
Using 3 keys instead of 2. Naive implementation suffers same vulnerability to \glsname{meet in the middle attack} as \glsname{2des}. Instead use EDE -- Encryption-Decryption-Encryption

\begin{tikzpicture}[every node/.style={minimum width=1.5cm,minimum height=0.75cm,draw,fill=gray!40,drop shadow={top color=black, bottom color=white, shadow xshift=0.25em, shadow yshift=-0.25em}, rounded corners}]
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none] (tp) {$P$};
    \node[right=of tp] (t1) {$E$};
    \node[right=of t1] (t2) {$D$};
    \node[right=of t2] (t3) {$E$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,right=of t3] (tc) {$C=E(k_3, D(k_2, E(k_1, P)))$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of t1] (tk1) {$k_1$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of t2] (tk2) {$k_2$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of t3] (tk3) {$k_3$};
    \draw[->] (tp) -- (t1);
    \draw[->] (t1) -- (t2);
    \draw[->] (t2) -- (t3);
    \draw[->] (t3) -- (tc);
    \draw[->] (tk1) -- (t1);
    \draw[->] (tk2) -- (t2);
    \draw[->] (tk3) -- (t3);

    \node[below=2cm of tp,minimum size=0cm,style=reset preactions,draw=none,fill=none] (bp) {$C$};
    \node[right=of bp] (b1) {$D$};
    \node[right=of b1] (b2) {$E$};
    \node[right=of b2] (b3) {$D$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,right=of b3] (bc) {$P=D(k_1, E(k_2, D(k_3, C)))$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of b1] (bk1) {$k_3$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of b2] (bk2) {$k_2$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of b3] (bk3) {$k_1$};
    \draw[->] (bp) -- (b1);
    \draw[->] (b1) -- (b2);
    \draw[->] (b2) -- (b3);
    \draw[->] (b3) -- (bc);
    \draw[->] (bk1) -- (b1);
    \draw[->] (bk2) -- (b2);
    \draw[->] (bk3) -- (b3);
\end{tikzpicture}

Above has 3 keys, but vulnerable to more sophisted MITM attack -- effectively only 112-bit security. Taking $k_1=k_3$ provides 80-bits of effective security.

\begin{tikzpicture}[every node/.style={minimum width=1.5cm,minimum height=0.75cm,draw,fill=gray!40,drop shadow={top color=black, bottom color=white, shadow xshift=0.25em, shadow yshift=-0.25em}, rounded corners}]
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none] (tp) {$P$};
    \node[right=of tp] (t1) {$E$};
    \node[right=of t1] (t2) {$D$};
    \node[right=of t2] (t3) {$E$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,right=of t3] (tc) {$C=E(k_1, D(k_2, E(k_1, P)))$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of t1] (tk1) {$k_1$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of t2] (tk2) {$k_2$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of t3] (tk3) {$k_1$};
    \draw[->] (tp) -- (t1);
    \draw[->] (t1) -- (t2);
    \draw[->] (t2) -- (t3);
    \draw[->] (t3) -- (tc);
    \draw[->] (tk1) -- (t1);
    \draw[->] (tk2) -- (t2);
    \draw[->] (tk3) -- (t3);

    \node[below=2cm of tp,minimum size=0cm,style=reset preactions,draw=none,fill=none] (bp) {$C$};
    \node[right=of bp] (b1) {$D$};
    \node[right=of b1] (b2) {$E$};
    \node[right=of b2] (b3) {$D$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,right=of b3] (bc) {$P=D(k_1, E(k_2, D(k_1, C)))$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of b1] (bk1) {$k_1$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of b2] (bk2) {$k_2$};
    \node[minimum size=0cm,style=reset preactions,draw=none,fill=none,above=of b3] (bk3) {$k_1$};
    \draw[->] (bp) -- (b1);
    \draw[->] (b1) -- (b2);
    \draw[->] (b2) -- (b3);
    \draw[->] (b3) -- (bc);
    \draw[->] (bk1) -- (b1);
    \draw[->] (bk2) -- (b2);
    \draw[->] (bk3) -- (b3);
\end{tikzpicture}
\section{Block Cipher Modes of Operation}
\begin{center}\begin{tabular}{llll}
        \multicolumn{1}{c}{Orientation} & \multicolumn{2}{c}{Mode} & \multicolumn{1}{c}{Use}                                      \\\toprule
        \multirow{2}{*}{Block}          & \acrshort{ecb}           & \acrlong{ecb}           & single block                       \\
                                        & \acrshort{cbc}           & \acrlong{cbc}           & commonly used                      \\\midrule
        \multirow{3}{*}{Stream}         & \acrshort{ofb}           & \acrlong{ofb}           & no random access                   \\
                                        & \acrshort{cfb}           & \acrlong{cfb}           & self-synchronized stream cipher    \\
                                        & \acrshort{ctr}           & \acrlong{ctr}           & very efficient, very commonly used \\\bottomrule
    \end{tabular}
\end{center}
\vspace*{0.25in}
\begin{center}
    \begin{tabular}{lp{0.4\textwidth}p{0.4\textwidth}}
        \multicolumn{1}{c}{Mode}        & \multicolumn{1}{c}{Advantages}                       & \multicolumn{1}{c}{Disadvantages}                                    \\\toprule
        \multirow{3}{*}{\acrshort{ecb}} & blocks can be encrypted/decrypted in parallel        & identical plaintext $\rightarrow$ identical ciphertext               \\\cmidrule{2-3}
                                        &                                                      & attacker can rearrange or remove blocks from ciphertext              \\\midrule
        \multirow{7}{*}{\acrshort{cbc}} & hides patterns in the plaintext                      & blocks cannot be encrypted in parallel                               \\\cmidrule{2-3}
                                        & \multirow{2}{*}{blocks can be decrypted in parallel} & attacker might be able to rearrange or remove blocks from ciphertext \\\cmidrule{2-3}
                                        &                                                      & IV needs integrity protection                                        \\\cmidrule{3-3}
                                        &                                                      & attacker might be able to tamper with bits of the plaintext          \\\midrule
        \multirow{4}{*}{\acrshort{ofb}} & \multirow{2}{*}{bit errors do not propagate}         & blocks cannot be encrypted or decrypted in parallel                  \\\cmidrule{2-3}
                                        & \multirow{2}{*}{pre-computation is possible}         & attacker can tamper with the bits of the plaintext                   \\\midrule
        \multirow{6}{*}{\acrshort{cfb}} & blocks can be decrypted in parallel                  & blocks cannot be encrypted in parallel                               \\\cmidrule{2-3}
                                        & \multirow{2}{*}{self-synchronizing stream cipher}    & attacker might be able to tamper with the bits of the plaintext      \\\cmidrule{2-3}
                                        &                                                      & attacker might be able to rearrange or remove blocks                 \\\midrule
        \acrshort{ctr}                  & blocks can be encrypted and decrypted in parallel    & attacker can tamper with bits of the plaintext                       \\\cmidrule{2-3}
                                        & bit errors do not propagate                          &                                                                      \\\cmidrule{2-2}
                                        & pre-computation is possible                          &                                                                      \\\bottomrule
    \end{tabular}
\end{center}
\section{Public-Key Cryptography}
\glsname{public-key cryptography}, also called \glsname{asymmetric-key cryptography}

Use a pair of keys, one public, one private. Solves
\begin{itemize}[nosep]
    \item public-key encryption $\rightarrow$ key exchange
    \item digital signature $\rightarrow$ non-repudiation
\end{itemize}
\subsection{Public-Key Encryption}
\begin{itemize}[nosep]
    \item everyone knows public key $\rightarrow$ sender can encrypt
    \item received knows private key $\rightarrow$ receiver can decrypt
    \item attacker does not know private key $\rightarrow$ cannot decrypt
    \item public key can be published
\end{itemize}
3 algorithms:
\begin{itemize}[nosep]
    \item key generation $G \rightarrow (PU, PR)$
    \item encryption -- $E(PU, M) \rightarrow C$
          \begin{itemize}[nosep]\item takes public key $PU$ and plaintext $M$ and outputs ciphertext $C$\end{itemize}
    \item encryption -- $D(PR, C) \rightarrow P$
          \begin{itemize}[nosep]\item takes private key $PR$ and ciphertext $C$ and outputs plaintext $P$\end{itemize}
\end{itemize}
Unlike symmetric-key, requires largest keys and is much slower

\begin{tabular}{lll}
                   & Symmetric                  & Asymmetric                               \\\toprule
    Typical Design & series of subs. and perms. & hard mathematical problems               \\
    Key            & completely random          & special structure, expensive to generate \\
    Rec. Key Size  & 128 - 256 bits             & 2048 - 15360 bits                        \\
    Performance    & fast                       & slow                                     \\\bottomrule
\end{tabular}
\begin{multicols}{2}
    \subsection{RSA}
    Choose two large primes $p$ and $q$, set $n=pq$ and choose $e$ such that $\gcd(e, \varphi(n)) = 1$. Set $d=e^{-1}\bmod\varphi(n)$, then
    \begin{align*}PU&=(e, n)\\PR&=(d, n)\end{align*}

    Encrypt plaintext $M$ with $C=M^e \bmod{n}$ and decrypt with $M = C^d\bmod{n}$.

    \subsection{Security of RSA}
    Security comes from difficulty of determining $C^{\sfrac{1}{e}}\bmod{n}$ efficiently. Best known algorithm is to factor $n=pq$ and compute $e^{-1}\bmod{\varphi(n)}$. Integer factorization is assumed to be hard but this is unproved.

    Very slow encryption, so commonly used to encrypt a secret key for use with symmetric-key encryption. Comparable symmetric key security (number of bits):

    \begin{tabular}{ll}
        Symmetric & RSA   \\\toprule
        80        & 1024  \\
        128       & 3072  \\
        256       & 15360 \\\bottomrule
    \end{tabular}

    \subsection{ElGamal Encryption}
    Choose a large prime $q$, primitive root $\alpha$ of $q$, and $X \in \set{1, 2, \hdots, q - 1}$. Set $Y = \alpha^x\bmod{q}$ and \begin{align*}PU&=(q,\alpha,U)\\PR&=(q,\alpha,X)\end{align*}

    Encryption:

    Choose random $k\in\set{0,1,\hdots, q-2}$ and set $K=y^k\bmod{q}$. Then return $(C_1, C_2)$ where \begin{align*}C_1&=\alpha^k\bmod{q}\\C_2&=KM\bmod{q}\end{align*}

    Decryption:

    Set $K=C_1^X\bmod{q}$, then $M = C_2K^{-1}\bmod{q}$.

    \subsection{Security of ElGamal}
    Security comes from difficulty of discrete logarithm, widely believed to be computationally hard.

    Recover $X$ requires computing discrete-$\log_{\alpha}$ of $Y$ $\bmod{q}$.

    Recover $k$ requires computing discrete-$\log_{\alpha}$ of $C_1$ $\bmod{q}$.
    \subsection{Elliptic Curve Cryptography}
    Elliptic Curve is a set of points $(x,y)$ such that \[y^2=x^3+ax+b\] Binary operation $P + Q$: draw line through $P$ and $Q$, find where it intersects the curve, call this $R$. Then $P+Q = -R$. Combined with a point at infinity (the identity), forms an abelian (commutative) group. Can naturally define $kP = \underbrace{P + P + \dots + P}_{k-\text{times}}$ and so can implement ElGamal in a straightforward fashion.

    160-bit ECC is comparable in security to 1024-bit RSA key.
\end{multicols}
\section{Hash Functions}
A hash function $H$ maps a variable-length input to a fixed-length hash value. It must be
\begin{itemize}[nosep]
    \item efficient -- computing $H(M)$ is easy
    \item one-way -- finding an input for which the output is a given hash-value is hard
    \item collision-resistant -- finding two inputs for which the hash-values are the same is hard
    \item pseudorandom
\end{itemize}
\subsection{Security Requirements}
\begin{tabular}{lp{0.65\textwidth}}
    Requirement                           & Definition                                                          \\\toprule
    \glsname{preimage resistance}         & \multirow{2}{0.65\textwidth}{\glstext{one-way property}}            \\
    \glsname{one-way property}            &                                                                     \\\midrule
    \glsname{second preimage resistance}  & \multirow{2}{0.65\textwidth}{\glstext{weak collision resistance}}   \\
    \glsname{weak collision resistance}   &                                                                     \\\midrule
    \glsname{collision resistance}        & \multirow{2}{0.65\textwidth}{\glstext{strong collision resistance}} \\
    \glsname{strong collision resistance} &                                                                     \\\bottomrule
\end{tabular}
\subsection{Brute-Force Attacks}
Try random inputs until a collision is found. If output is $m$ bits, then probability of success for a single try is $2^{-m}$. Expected number of tries until success is $2^m$.

Collision resistance attacks are a consequence of the birthday paradox:
\begin{theorem}{The Birthday Paradox}{}
    The probability that a collision occurs given a random map from $\set{1, 2, \dots, n}$ to $\set{1, 2, \dots, m}$ is \[1 - \prod_{i=1}^{n-1}1 - \frac{i}{m}\]
\end{theorem}
Since $1-x\approx e^{-x}$, we have \[1 - \prod_{i=1}^{n-1}1 - \frac{i}{m}\approx 1 - e^{-\frac{n^2}{2m}}\]
so when $n=\bigOm{\sqrt{m}}$, a collision is likely.
\subsection{Iterative Hash Function}
Divide input $M$ into fixed-length blocks $M_1$, $M_2$, $\dots$, $M_n$. Then

\begin{tikzpicture}[node distance=1cm]
    \node[below left=2cm and 2.5cm of k] (k1) {$M_1$};
    \node[right= of k1] (k2) {$M_2$};
    \node[right= of k2] (k3) {$M_3$};
    \node[below right=2cm and 2.5cm of k] (km) {$M_n$};
    \draw[draw=none] (k3) -- (km) node[pos=0.5] (emptydots) {};


    \node[minimum size=1cm,draw,rectangle,below= of k1] (r1) {$f$};
    \node[minimum size=1cm,draw,rectangle,below= of k2] (r2) {$f$};
    \node[minimum size=1cm,draw,rectangle,below= of k3] (r3) {$f$};
    \node[below= 1.5cm of emptydots] (dots) {$\dots$};
    \node[minimum size=1cm,draw,rectangle,below= of km] (rm) {$f$};
    \node[left= of r1, align=center] (plaintext) {IV};
    \node[right= of rm, align=center] (ciphertext) {Hash Value};

    \draw[->] (k1) -- (r1.north);
    \draw[->] (k2) -- (r2.north);
    \draw[->] (k3) -- (r3.north);
    \draw[->] (km) -- (rm.north);

    \draw[->] (plaintext) -- (r1);
    \draw[->] (r1) -- (r2);
    \draw[->] (r2) -- (r3);
    \draw[->] (r3) -- (dots);
    \draw[->] (dots) -- (rm);
    \draw[->] (rm) -- (ciphertext);
\end{tikzpicture}
\begin{itemize}[nosep]
    \item IV: initialization vector
    \item $f$: compression function
          \begin{itemize}[nosep]
              \item one-way and collision resistant
              \item takes two fixed-length inputs, produces one fixed-length output
          \end{itemize}
\end{itemize}
\subsection{Merkle-Damg\r{a}rd Construction}
Method to build cryptographic hash frunctions from compression functions.

\begin{tikzpicture}[node distance=1cm]
    \node (m1) {$M_1$};
    \node[right= of m1] (m2) {$M_2$};
    \node[right=2cm of m2] (mn) {$M_n$};
    \draw[draw=none] (m2) -- (mn) node[pos=0.5] (emptydots) {};
    \node[node distance=0.25cm, right= of mn] (pad) {length padding};



    \node[minimum size=1cm,draw,rectangle,below= of m1] (f1) {$f$};
    \node[minimum size=1cm,draw,rectangle,below= of m2] (f2) {$f$};
    \node[minimum size=1cm,draw,rectangle,below= of mn] (fn) {$f$};
    \draw[draw=none] (f2) -- (fn) node[pos=0.5] (dots) {$\dots$};
    \node[minimum size=1cm,draw,rectangle,below= of pad] (lp) {$f$};
    \node[left= of f1, align=center] (iv) {IV};
    \node[draw=none,right=of lp] (fin) {finalization};
    \node[right= of fin, align=center] (hash) {Hash};

    \draw[->] (m1) -- (f1.north);
    \draw[->] (m2) -- (f2.north);
    \draw[->] (mn) -- (fn.north);
    \draw[->] (pad) -- (lp);

    \draw[->] (iv) -- (f1);
    \draw[->] (f1) -- (f2);
    \draw[->] (f2) -- (dots);
    \draw[->] (dots) -- (fn);
    \draw[->] (fn) -- (lp);
    \draw[->,dashed] (lp) -- (fin);
    \draw[->,dashed] (fin) -- (hash);

    \draw[dashed] (fin.south west) rectangle (fin.north east);
\end{tikzpicture}

length padding (Merkle-Damg\r{a}rd Strengthening) includes the length of the input as well as a fixed pattern

if $f$ is collision resistant and proper length padding is used, hash function is collision resistant

\subsection{CBC Hash Functions}
\begin{tabular}{lll}
    Algorithm              & Properties                             & Security                                  \\\toprule
    \multirow{4}{*}{MD5}   & based on Merkle-Damg\r{a}rd            & not collision resistant                   \\
                           & compression func 4 rounds, 16 ops each & cryptanalysis can break in $2^{18}$ steps \\
                           & 512-bit block                          & less than 1 sec on average computer       \\
                           & 128-bit hash                           &                                           \\\midrule
    SHA-1                  & 160-bit hash                           & collision in $2^{65}$ steps               \\\midrule
    \multirow{2}{*}{SHA-2} & family: SHA-224, 256, 384, 512         & similar to SHA-1, some weaknesses         \\
                           & output 224, 256, 384, 512 bit hash     & no practical attacks yet                  \\\midrule
    \multirow{2}{*}{SHA-3} & sponge construction                    &                                           \\
                           & arbitrary output length                &                                           \\\bottomrule
\end{tabular}

\begin{tabular}{ll}
    Algorithm & Security          \\\toprule
    MD5       & not secure at all \\
    SHA-1     & not secure        \\
    SHA-2     & mostly secure     \\
    SHA-3     & secure            \\\bottomrule
\end{tabular}
\section{Message Authentication}
\section{Digital Signatuers}
\section{Key Distribution}
\section{Public-Key Distribution}
\clearpage

\glsaddall
\printglossary[nonumberlist]
\printglossary[nonumberlist,type=\acronymtype]

\end{document}
